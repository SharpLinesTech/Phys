#ifndef PHYS_COLLISION_COLLISION_H
#define PHYS_COLLISION_COLLISION_H

#include "phys/collision/collision_object.h"
#include "phys/util_types/static_vector.h"

namespace phys {

template <typename CFG>
struct Contact {
  using vec3_t = typename CFG::vec3_t;
  using real_t = typename CFG::real_t;

  // Position of the contact on each object (in world and object space)
  std::array<vec3_t, 2> os_position;
  std::array<vec3_t, 2> ws_position;

  vec3_t ws_normal;  // relative to the second object

  // Distance between the object's contact points.
  // A negative valeu implies penetration, a positive value means there is no
  // collision yet, but we are within the margin.
  real_t distance;

  real_t total_restitution = 0;
};

template <typename CFG>
struct Collision {
  using real_t = typename CFG::real_t;

  using points_container =
      StaticVector<Contact<CFG>, CFG::max_contact_points_per_collision>;

  // The objects involved in the collision.
  std::array<col::Object<CFG>*, 2> objects;

  // The contact points generated by the collision.
  points_container points;

  // Which simulation island this collision has been assigned to.
  mutable uint32_t island_id_;

  real_t getContactDistance() {
    return 0.02f;
  }

  real_t getContactDistanceSq() {
    return 0.02f * 0.02f;
  }

  void refresh() {
    auto const& transform_0 = objects[0]->transform;
    auto const& transform_1 = objects[1]->transform;

    for(std::size_t i = 0; i < points.size();) {
      points[i].ws_position[0] =
          transform_0.applyToVec(points[i].os_position[0]);
      points[i].ws_position[1] =
          transform_1.applyToVec(points[i].os_position[1]);

      // This ws_normal feels wrong. If the objects are rotating, that'll be
      // wrong.
      points[i].distance =
          dot(points[i].ws_position[0] - points[i].ws_position[1],
              points[i].ws_normal);

      bool remove_point = false;
      if(points[i].distance > getContactDistance()) {
        remove_point = true;
      } else {
        auto projected =
            points[i].ws_position[0] - points[i].ws_normal * points[i].distance;
        auto projected_diff = points[i].ws_position[1] - projected;
        auto dist_2d = dot(projected_diff, projected_diff);
        ;
        if(dist_2d > getContactDistanceSq()) {
          remove_point = true;
        }
      }
      if(remove_point) {
        if(i != points.size() - 1) {
          std::swap(points[i], points[points.size() - 1]);
        }
        points.pop_back();
      } else {
        ++i;
      }
    }
  }
};
}

#endif